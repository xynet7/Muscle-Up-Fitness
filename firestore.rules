/**
 * This ruleset enforces a security model for the MuscleUp gym membership application.
 *
 * Core Philosophy:
 * The security model is based on strict user ownership and administrative roles.
 * Users have complete control over their own data tree (profile, subscriptions, receipts),
 * but are completely isolated from other users' data. A separate, non-hierarchical
 * collection (`/roles_admin`) is used to manage administrator privileges, granting
 * them specific management capabilities over global and user data.
 *
 * Data Structure:
 * - /membershipPlans/{membershipPlanId}: Publicly readable data about available gym plans.
 * - /users/{userId}: A user's root profile document.
 * - /users/{userId}/subscriptions/{subscriptionId}: A user's private subscription records.
 * - /users/{userId}/attendance/{attendanceId}: A user's private attendance records.
 * - /subscriptions_flat/{subscriptionId}: A denormalized collection of all subscriptions for admin querying.
 * - /roles_admin/{userId}: A lookup collection where the existence of a document signifies
 *   that the user is an administrator.
 *
 * Key Security Decisions:
 * - User data is segregated under a path containing their UID (`/users/{userId}`),
 *   making ownership checks fast and simple.
 * - Listing users from the top-level `/users` collection is disallowed to prevent
 *   user enumeration and protect privacy.
 * - Membership plans are public for any visitor to see, but can only be created or
 *   modified by administrators.
 * - A denormalized `subscriptions_flat` collection is used for admin dashboards,
 *   preventing the need for insecure, broad queries on the `/users` collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingDoc() {
      return resource != null;
    }

    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isUserIdConsistentOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    // -------------------------------------------------------------------------
    // Subscription-specific Helper Functions
    // -------------------------------------------------------------------------

    function isSubscriptionOwnerConsistent(userId) {
      return request.resource.data.userId == userId;
    }
    
    function isSubscriptionOwnerImmutable() {
        return resource.data.userId == request.resource.data.userId;
    }

    function isCreatingPendingSubscription(userId) {
      let data = request.resource.data;
      return isOwner(userId)
        && isSubscriptionOwnerConsistent(userId)
        && data.status == 'pending'
        && !('startDate' in data)
        && !('endDate' in data)
        && data.requestedDate == request.time;
    }
    
    // -------------------------------------------------------------------------
    // Attendance-specific Helper Functions
    // -------------------------------------------------------------------------
    function isAttendanceOwnerConsistent(userId) {
      return request.resource.data.userId == userId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------
    
    match /membershipPlans/{membershipPlanId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    match /users/{userId} {
      allow get, update, delete: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId) && isUserIdConsistentOnCreate(userId);
    }
    
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isCreatingPendingSubscription(userId);
      // An admin can approve (pending -> active)
      // A user can cancel their own active subscription (not yet implemented in UI)
      allow update: if isAdmin() || (isOwner(userId) && isExistingDoc() && isSubscriptionOwnerImmutable());
      allow delete: if false; // Disallow deletion for record keeping
    }
    
     match /users/{userId}/attendance/{attendanceId} {
      // User can read their own attendance, Admins can read anyone's attendance.
      allow get, list: if isOwner(userId) || isAdmin();
      // User can create and delete their own attendance records.
      // Admin cannot create/delete on behalf of the user.
      allow create, delete: if isOwner(userId) && isAttendanceOwnerConsistent(userId);
      allow update: if false; // Disallow updates, just create/delete.
    }
    
    /**
     * @description Denormalized collection for admin dashboard. Readable only by admins.
     *              Writes are handled by backend functions/triggers (or client for simplicity here)
     *              but controlled by rules on the source collection.
     */
    match /subscriptions_flat/{subscriptionId} {
        allow get, list: if isAdmin();
        // The security of these writes is primarily enforced by the rules on the
        // /users/{userId}/subscriptions/{subscriptionId} path.
        allow create: if isSignedIn();
        allow update: if isAdmin();
        allow delete: if false;
    }
    
    match /roles_admin/{userId} {
      // Allow a user to read their OWN admin document to verify their role on the client.
      // This is secure because it checks if the requester's UID matches the document ID they are trying to access.
      allow get: if request.auth.uid == userId;
      // Disallow anyone from listing all admins or making changes from the client.
      allow list, create, update, delete: if false;
    }
  }
}
